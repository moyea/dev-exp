## 小数在内存中是如何存储的
小数在内存中是以浮点数的形式存储的。浮点数并不是一种数值分类，它和整数、小数、实数等不是一个层面的概念。浮点数是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。

C语言使用定点数格式来存储 short、int、long 类型的整数，使用浮点数格式来存储 float、double 类型的小数。整数和小数在内存中的存储格式不一样。

我们在学习C语言时，通常认为浮点数和小数是等价的，并没有严格区分它们的概念，这也并没有影响到我们的学习，原因就是浮点数和小数是绑定在一起的，只有小数才使用浮点格式来存储。

其实，整数和小数可以都使用定点格式来存储，也可以都使用浮点格式来存储，但实际情况却是，C语言使用定点格式存储整数，使用浮点格式存储小数，这是在“数值范围”和“数值精度”两项重要指标之间追求平衡的结果，稍后我会给大家带来深入的剖析。

> 计算机的设计是一门艺术，很多实用技术都是权衡和妥协的结果。

浮点数和定点数中的“点”指的就是小数点！对于整数，可以认为小数点后面都是零，小数部分是否存在并不影响整个数字的值，所以干脆将小数部分省略，只保留整数部分。定点数所谓定点数，就是指小数点的位置是固定的，不会向前或者向后移动

假设我们用4个字节（32位）来存储无符号的定点数，并且约定，前16位表示整数部分，后16位表示小数部分，如下图所示：

![](/images/32位定点数.png)

如此一来，小数点就永远在第16位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。例如，在内存中存储了 10101111  00110001  01011100  11000011，那么对应的小数就是 10101111  00110001 . 01011100  11000011，非常直观。精度小数部分的最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的31位都是精确数字。从二进制的角度看，这种定点格式的小数，最多有 32 位有效数字，但是能保证的是 31 位；也就是说，整体的精度为 31~32 位。
数值范围将内存中的所有位（Bit）都置为 1，小数的值最大，为 2<sup>16</sup> - 2<sup>-16</sup>，极其接近 2<sup>16</sup>，换算成十进制为 65536。将内存中最后一位（第32位）置1，其它位都置0，小数的值最小，为2<sup>-16</sup>。

综述用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。反面例子在科学计算中，小数的取值范围很大，最大值和最小值的差距有上百个数量级，使用定点数来存储将变得非常困难。

例如，电子的质量为:  
0.0000000000000000000000000009 克 = 9 × 10<sup>-28</sup> 克
太阳的质量为:
2000000000000000000000000000000000 克 = 2 × 10<sup>33</sup> 克  

如果使用定点数，那么只能按照=前面的格式来存储，这将需要很大的一块内存，大到需要几十个字节。  
更加科学的方案是按照=后面的指数形式来存储，这样不但节省内存，也非常直观。这种以指数的形式来存储小数的解决方案就叫做浮点数。浮点数是对定点数的升级和优化，克服了定点数取值范围太小的缺点。

浮点数C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：  
flt = sign × mantisa × base exponent

对各个部分的说明：  

* flt 是要表示的小数。  
* sign 用来表示 flt 的正负号，它的取值只能是 0 或 1：取值为 0 表示 flt 是正数，取值为 1 表示 flt 是负数。
* base 是基数，或者说进制，它的取值大于等于 2（例如，2 表示二进制、10 表示十进制、16 表示十六进制……）。数学中常见的科学计数法是基于十进制的，例如 6.93 × 10<sup>13</sup>；计算机中的科学计数法可以基于其它进制，例如 1.001 × 2<sup>7</sup> 就是基于二进制的，它等价于 1001 0000。
* mantissa 为尾数，或者说精度，是 base 进制的小数，并且 1 ≤ mantissa ＜ base，这意味着，小数点前面只能有一位数字；
* exponent 为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。

以float为例，32位浮点数内存占用示意图：

![](/images/32位浮点数.jpg)

这32个二进制位的内存编号从高到低(从31->0),共包含如下几个部分:

**sign: 符号位，即图中蓝色方块**  
**biased exponent: 偏移后的指数位，即图中绿色方块**  
**fraction: 尾数位，即图中橙色方块**  

### 偏移后的指数位:

指数位占据第30位~23位这8位。用于表示以2为底的指数。8位二进制可以表示2<sup>8</sup>=256种状态，指数位用于表示[-127, 128]范围内的指数。

（1）二进制小数转化为十进制小数
比如把二进制小数110.11转化为十进制小数，步骤如下：
(110.11)<sub>2</sub> = (1 x 2<sup>2</sup>)+(1 x 2<sup>1</sup>)+ (0 x 2<sup>0</sup>)+(1 x 2<sup>-1</sup>)+(1 x 2<sup>-2</sup>) = 6.75

（2）十进制小数转化为二进制小数

   方法是这样的：先分别把十进制小数的整数部分和小数部分转化为二进制，然后合并即可。当然整数部分很简单，直接进行二进制转化，而小数部分就不一样了。

具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的整数部分为零，或者整数部分为1，此时0或1为二进制的最后一位，或者达到所要求的精度为止。比如：

将十进制小数173.8125转化为二进制小数
(173)<sub>10 </sub>= (10101101)<sub>2</sub>
0.8125 x 2 = 1.6250 -------- 1  
0.6250 x 2 = 1.2500 -------- 1
0.2500 x 2 = 0.5000 -------- 0
0.5000 x 2 = 1.0000 -------- 1
即(0.8125)<sub>10</sub> = (0.1101)<sub>2</sub>

所以最终得到: (173.8125)<sub>10</sub> = (10101101.1101)<sub>2</sub>


下面我们以 19.625 为例来演示如何将小数转换为浮点格式。

当 base 取值为 10 时，19.625 的浮点形式为：
19.625 = 1.9625 × 10<sup>1</sup>
当 base 取值为 2 时，将 19.625 转换成二进制为 10011.101，用浮点形式来表示为：
19.625 = 10011.101 = 1.0011101×2<sup>4</sup>
19.625 整数部分的二进制形式为：
19 = 1×2<sup>4</sup> + 0×2<sup>3</sup> + 0×2<sup>2</sup> + 1×2<sup>1</sup> + 1×2<sup>0</sup> = 10011
小数部分的二进制形式为：
0.625 = 1×2<sup>-1</sup> + 0×2<sup>-2</sup> + 1×2<sup>-3</sup> = 101
将整数部分和小数部分合并在一起：
19.625 = 10011.101
可以看出，当基数（进制）base 确定以后，指数 exponent 实际上就成了小数点的移动位数：
exponent 大于零，mantissa 中的小数点右移 exponent 位即可还原小数的值；
exponent 小于零，mantissa 中的小数点左移 exponent 位即可还原小数的值。

换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由 exponent 决定，所以我们将这种表示小数的方式称为浮点数。
二进制形式的浮点数的存储虽然C语言标准没有规定 base 使用哪种进制，但是在实际应用中，各种编译器都将 base 实现为二进制，这样不仅贴近计算机硬件（任何数据在计算机底层都以二进制形式表示），还能减少转换次数。

接下来我们就讨论一下如何将二进制形式的浮点数放入内存中。

原则上讲，上面的科学计数法公式中，符号 sign、尾数 mantissa、基数 base 和指数 exponent 都是不确定因素，都需要在内存中体现出来。但是现在基数 base 已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号 sign、尾数 mantissa、指数 exponent 这三个不确定的元素就可以了。

仍然以 19.625 为例，将它转换成二进制形式的浮点数格式：
19.625 = 1.0011101×2<sup>4</sup>
此时符号 sign 为 0，尾数 mantissa 为 1.0011101，指数 exponent 为 4。1) 符号的存储符号的存储很容易，就像存储 short、int 等普通整数一样，单独分配出一个位（Bit）来，用 0 表示正数，用 1 表示负数。对于 19.625，这一位的值是 0。2) 尾数的存储当采用二进制形式后，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：尾数的整数部分一定为 1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可。对于 1.0011101，就是把 0011101 放入内存。

我们不妨将真实的尾数命名为 mantissa，将内存中存储的尾数命名为 mant，那么它们之间的关系为：
mantissa = 1.mant

如果 base 采用其它进制，那么尾数的整数部分就不是固定的，它有多种取值的可能，以十进制为例，尾数的整数部分可能是 1~9 之间的任何一个值，这样一来尾数的整数部分就不能省略了，必须在内存中体现出来。而将 base 设置为二进制就可以节省掉一个位（Bit）的内存，这也算是采用二进制的一点点优势。
3) 指数的存储指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。

short、int、long 等类型的整数在内存中的存储采用的是补码加符号位的形式，数值在写入内存之前必须先进行转换，读取以后还要再转换一次。但是为了提高效率，避免繁琐的转换，指数的存储并没有采用补码加符号位的形式，而是设计了一套巧妙的解决方案，稍等我会为您解开谜团。为二进制浮点数分配内存C语言中常用的浮点数类型为 float 和 double；float 始终占用 4 个字节，double 始终占用 8 个字节。

float 的内存分布: 符号位(1 Bit) + 指数部分(8 Bits)  + 尾数部分(23 Bits)  
double的内存分布: 符号位(1 Bit) + 指数部分(11 Bits) + 尾数部分(52 Bits)

浮点数的内存被分成了三部分，分别用来存储符号 sign、尾数 mantissa 和指数 exponent ，当浮点数的类型确定后，每一部分的位数就是固定的。

符号 sign 可以不加修改直接放入内存中，尾数 mantissa 只需要将小数部分放入内存中，最让人疑惑的是指数 exponent 如何放入内存中，这也是我们在前面留下的一个谜团，下面我们以 float 为例来揭开谜底。

float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值 127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。19.625 转换后的指数为 4，4+127 = 131，131 换算成二进制为 1000 0011，这就是 19.626 的指数部分在 float 中的最终存储形式。

先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。

中间值的求取有固定的公式。设中间值为 median，指数部分占用的内存为 n 位，那么中间值为：
median = 2n-1 - 1
对于 float，中间值为 28-1 - 1 = 127；对于 double，中间值为 211-1 -1 = 1023。

我们不妨将真实的指数命名为 exponent，将内存中存储的指数命名为 exp，那么它们之间的关系为：
exponent = exp - median
也可以写作：
exp = exponent + median

用代码验证 float 的存储19.625 转换成二进制的指数形式为：
19.625 = 1.0011101×2<sup>4</sup>
此时符号为 0；尾数为 1.0011101，截掉整数部分后为 0011101，补齐到 23 Bits 后为 001 1101 0000 0000 0000 0000；指数为4，4+127 = 131，131换算成二进制为 1000 0011。

综上所述，float 类型的 19.625 在内存中的值为：0 - 10000011 - 001 1101 0000 0000 0000 0000。

mant 的位数不足，在前面补齐两个 0 即可。

尾数位: 占据剩余的22位到0位这23位. 用于存储尾数.

在以二进制格式存储十进制浮点数时, 首先需要把十进制浮点数表示为二进制格式, 以十进制数20.5举例:
十进制浮点数20.5 = 二进制10100.1
然后需要把这个二进制数转换为以2为底的指数形式:
(10100.1)<sub>2</sub> = 1.01001 x 2<sup>4</sup>
注意转换时, 对于乘号左边, 加粗的那个二进制数1.01001, 需要把小数点放在左起第一位和第二位之间. 且第一位需要是个非0数. 这样表示好之后, 其中的1.01001就是尾数.

用 二进制数 表示 十进制浮点数 时, 表示为尾数 x 指数的形式, 并把尾数的小数点放在第一位和第二位之间, 然后保证第一位数非0, 这个处理过程叫做规范化(normalized)

我们再来看看规范化之后的这个数: 1.01001 * 2<sup>4</sup>

其中1.01001是尾数,而4就是偏移前的指数(unbiased exponent), 上文讲过, 32位单精度浮点数的偏移量(bias)为127, 所以这里加上偏移量之后, 得到的偏移后指数(biased exponent)就是 4 + 127 = 131, 131转换为二进制就是1000 0011

现在还需要对尾数做一些特殊处理

1. 隐藏高位1.

你会发现, 尾数部分的最高位始终为**1**. 比如这里的  **1**.01001, 这是因为前面说过, 规范化之后, 尾数中的小数点会位于左起第一位和第二位之间. 且第一位是个非0数. 而二进制中, 每一位可取值只有0或1, 如果第一位非0, 则第一位只能为1. 所以在存储尾数时, 可以省略前面的 1和小数点. 只记录尾数中小数点之后的部分, 这样就节约了一位内存. 所以这里只需记录剩余的尾数部分: 01001

所以, 以后再提到尾数, 如无特殊说明, 指的其实是隐藏了整数部分1之后, 剩下的小数部分

2. 低位补0

有时候尾数会不够填满尾数位(即图中的橙色格子). 比如这里的, 尾数01001不够23位

此时, 需要在低位补零, 补齐23位. 之所以在低位补0, 是因为尾数中存储的本质上是二进制的小数部分, 所以如果想要在不影响原数值的情况下, 填满23位, 就需要在低位补零. 

比如,  要把二进制数1.01在不改变原值的情况下填满八位内存, 写出来就应该是: 1.010 0000, 即需要在低位补0

同理, 本例中因为尾数部分存储的实际上是省略了整数部分 1.之后剩余的小数部分,所以这里补0时也需要在低位补0
原尾数是:     01001(不到23位)

补零之后是:  0100 1000 0000 0000 000  (补至23位)


### 精度问题
对于十进制小数，整数部分转换成二进制使用“展除法”（就是不断除以 2，直到余数为 0），一个有限位数的整数一定能转换成有限位数的二进制。但是小数部分就不一定了，小数部分转换成二进制使用“乘二取整法”（就是不断乘以 2，直到小数部分为 0），一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是 5 的小数才有可能转换成有限位数的二进制，其它的小数都不行。

float 和 double 的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。

对于 float，尾数部分有 23 位，再加上一个隐含的整数 1，一共是 24 位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的23位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有 24 位有效数字，但是能保证的是 23 位；也就是说，整体的精度为 23~24 位。如果转换成十进制，224 = 16 777 216，一共8位；也就是说，最多有 8 位有效数字，但是能保证的是 7 位，从而得出整体精度为 7~8 位。

对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。

#### IEEE 754 标准

浮点数的存储以及加减乘除运算是一个比较复杂的问题，很多小的处理器在硬件指令方面甚至不支持浮点运算，其他的则需要一个独立的协处理器来处理这种运算，只有最复杂的处理器才会在硬件指令集中支持浮点运算。省略浮点运算，可以将处理器的复杂度减半！如果硬件不支持浮点运算，那么只能通过软件来实现，代价就是需要容忍不良的性能。
PC 和智能手机上的处理器就是最复杂的处理器了，它们都能很好地支持浮点运算。
在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。

作为处理器行业的老大，Intel 早就意识到了这个问题，并打算一统浮点数的世界。Intel 在研发 8087 浮点数协处理器时，聘请到加州大学伯克利分校的 William Kahan 教授（最优秀的数值分析专家之一）以及他的两个伙伴，来为 8087 协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于 1985 年正式发布，这就是 IEEE 754 标准，它等同于国际标准 ISO/IEC/IEEE 60559。
IEEE 是 Institute of Electrical and Electronics Engineers 的简写，中文意思是“电气和电子工程师协会”。
IEEE 754 简直是天才一般的设计，William Kahan 教授也因此获得了 1987 年的图灵奖。图灵奖是计算机界的“诺贝尔奖”。

##### 特殊值
IEEE 754 标准规定，当指数 exp 的所有位都为 1 时，不再作为“正常”的浮点数对待，而是作为特殊值处理：  
如果此时尾数 mant 的二进制位都为 0，则表示无穷大：  
如果符号 sign 为 1，则表示负无穷大；  
如果符号 sign 为 0，则表示正无穷大。  
如果此时尾数 mant 的二进制位不全为 0，则表示 NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。

##### 非规格化浮点数
当指数 exp 的所有二进制位都为 0 时，情况也比较特殊。

对于“正常”的浮点数，尾数 mant 隐含的整数部分为 1，并且在读取浮点数时，内存中的指数 exp 要减去中间值 median 才能还原真实的指数 exponent，也即：
mantissa = 1.mant
exponent = exp - median

但是当指数 exp 的所有二进制位都为 0 时，一切都变了！尾数 mant 隐含的整数部分变成了 0，并且用 1 减去内存中的指数 exp 才能还原真实的指数 exponent，也即：
mantissa = 0.mant
exponent = 1 - exp
对于 float，exponent = 1 - 127 = -126，指数 exponent 的值恒为 -126；对于 double，exponent = 1 - 1023 = -1022，指数 exponent 的值恒为 -1022。

当指数 exp 的所有二进制位都是 0 时，我们将这样的浮点数称为“非规格化浮点数”；当指数 exp 的所有二进制位既不全为 0 也不全为 1 时，我们称之为“规格化浮点数”；当指数 exp 的所有二进制位都是 1 时，作为特殊值对待。 也就是说，究竟是规格化浮点数，还是非规格化浮点数，还是特殊值，完全看指数 exp。+0 和 -0 的表示对于非规格化浮点数，当尾数 mant 的所有二进制位都为 0 时，整个浮点数的值就为 0：
如果符号 sign 为 0，则表示 +0；
如果符号 sign 为 1，则表示 -0。

IEEE 754 为什么增加非规格化浮点数我们以 float 类型为例来说明。

对于规格化浮点数，当尾数 mant 的所有位都为 0、指数 exp 的最低位为 1 时，浮点数的绝对值最小（符号 sign 的取值不影响绝对值），为 1.0 × 2<sup>-126</sup>，也即 2<sup>-126</sup>。

对于一般的计算，这个值已经很小了，非常接近 0 值了，但是对于科学计算，它或许还不够小，距离 0 值还不够近，非规格化浮点数就是来弥补这一缺点的：非规格化浮点数可以让最小值更小，更加接近 0 值。

对于非规格化浮点数，当尾数的最低位为 1 时，浮点数的绝对值最小，为 2<sup>-23</sup> × 2<sup>-126</sup> = 2<sup>-149</sup>，这个值比 2<sup>-126</sup> 小了 23 个数量级，更加即接近 0 值。

##### 舍入模式
浮点数的尾数部分 mant 所包含的二进制位有限，不可能表示太长的数字，如果尾数部分过长，在放入内存时就必须将多余的位丢掉，取一个近似值。究竟该如何来取这个近似值，IEEE 754 列出了四种不同的舍入模式。

1. 舍入到最接近的值就是将结果舍入为最接近且可以表示的值，这是默认的舍入模式。最近舍入模式和我们平时所见的“四舍五入”非常类似，但有一个细节不同。

	对于最近舍入模式，IEEE 754 规定，当有两个最接近的可表示的值时首选“偶数”值；而对于四舍五入模式，当有两个最接近的可表示的值时要选较大的值。以十进制为例，就是对.5的舍入上采用偶数的方式，请看下面的例子。

	最近舍入模式：Round(0.5) = 0、Round(1.5) = 2、Round(2.5) = 2
	
	四舍五入模式：Round(0.5) = 1、Round(1.5) = 2、Round(2.5) = 3

2. 向 +∞ 方向舍入（向上舍入）会将结果朝正无穷大的方向舍入。标准库函数 ceil() 使用的就是这种舍入模式，例如，ceil(1.324) = 2，Ceil(-1.324) = -1。

3. 向 -∞ 方向舍入（向下舍入）会将结果朝负无穷大的方向舍入。标准库函数 floor() 使用的就是这种舍入模式，例如，floor(1.324) = 1，floor(-1.324) = -2。
4.  向 0 舍入（直接截断）会将结果朝接近 0 的方向舍入，也就是将多余的位数直接丢掉。C语言中的类型转换使用的就是这种舍入模式，例如，(int)1.324 = 1，(int) -1.324 = -1。

**总结**: 与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。

### 参考链接
[http://www.heike123.com/forum.php?mod=viewthread&tid=1018](http://www.heike123.com/forum.php?mod=viewthread&tid=1018)

