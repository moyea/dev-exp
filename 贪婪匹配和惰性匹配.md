# 贪婪匹配和惰性匹配

## 贪婪匹配

假定我们想用一个正则表达式来验证一个HTML标签。我们知道输入的是一个有效的HTML文件，因此正则不需要处理无效的尖括号(<>)使用。也就是说在尖括号之间的就是一个HTML标签。

许多刚接触正则表达式的人可能会这样写 `<.+>` 。当我们将这个正则应用到字符串 `This is a <EM>first</EM> test` 。预期我们想这个正则先匹配 `<EM>` 之后再匹配 `</EM>`。

但是并没有。这个正则会匹配 字符串`<EM>first</EM>`。显然不是我们想要的。原因在于 `+` 号是贪婪的。也就是说 `+` 会导致正则引擎尽可能多的重复 `+` 号之前的标识。只有当它导致整个正则表达式失败时，正则表达式引擎才会回溯。也就是说，它将返回 `+` ，使其放弃最后一次迭代，并继续执行正则表达式的其余部分。

像 `+` 一样，`*` 和 `{}` 的重复也是贪婪的。

### 深入了解正则表达式引擎

正则表达式中的第一个标记是 `<` 。这是一个字面值。它将匹配的第一个位置是字符串中的第一个 `<` 。下一个标记是 `.` ，它匹配除换行符以外的任何字符。`.` 由 `+` 重复，`+` 表示贪婪。因此，引擎将尽可能多的重复该点。`.` 匹配 `E`，因此正则表达式继续尝试将 `.` 与下一个字符匹配。`M` 匹配，该点再次重复。下一个字符是 `>`, 现在可以看到问题了，`.` 匹配 `>`，引擎继续重复 `.`。该点将匹配字符串中的所有剩余字符。当引擎在字符串结束时，点失败。只有在这一点上，正则表达式引擎才会继续下一个标记：`>`。

到目前为止，`<.+` 已匹配`<EM>first</EM> test`并且引擎已到达字符串的末尾。`>`不能在这里匹配。引擎记住 `+` 重复 `.` 的次数比要求的多（`+` 要求 `.` 只匹配一次 ）。引擎不会承认失败，而是回溯。它会将 `+` 的重复次数减少一，然后继续尝试正则表达式的其余部分。

所以`<.+` 减少到`<EM>first</EM> tes` 。正则表达式中的下一个标记仍然是`>` 。但是现在字符串中的下一个字符时`t`。同样，无法匹配，引擎进一步回溯。到目前为止的总匹配减少到 `<EM>first</EM> te` 。但`>` 仍然无法匹配。所以引擎继续回溯知道匹配 `.+` 减少到 `EM>first</EM`。现在，`>` 可以匹配字符串中的下一个字符。正则表达式中最后一个标记已匹配。引擎报告 `<EM>first</EM>`。

由于正则引擎迫切希望返回匹配结果。所以它不会继续回溯去查看是不是有其他可能的匹配。它将报告它找到的第一个有效的匹配。由于贪婪，这是最左边最长的匹配。

### 懒惰匹配(非贪婪匹配)

解决上诉问题的快速方法是让 `+` 变的懒惰而不是贪婪。惰性量词有时也被称为"非贪婪"。可以通过在正则表达式 `+` 后面加一个 `?` 来表示。可以对 `*` , `{}` 和 `?` 本身执行相同的操作。此时例子变成 `<.+?>`。再来看看正则表达式引擎。

同样，正则`<`匹配字符串中的第一个`<`。一个标记是`.`，这次是惰性重复。这告诉正则尽可能少地匹配`.`。最小值为一。因此引擎将`.` 与`E`匹配。已满足要求，引擎继续使用 `>` 去匹配`M`，此时失败了。同样，引擎回溯。但这一次，引擎将迫使惰性`+` 扩大而不是缩小其范围。所以正则`.+`扩展为 `EM` , 引擎再次尝试继续 `>`，现在 `>` 匹配成功。正则表达式中的最后一个标记已匹配。引擎报告`<EM>` 已成功匹配。

### 代替惰性匹配

针对上述的例子，有一种比惰性`+`更好的选择。我们可以使用贪婪的`+` 和否定字符类:`<[^<]+>`。这个更好的原因是因为回溯。使用惰性`+`时，引擎必须回溯它试图匹配HTML标记中的每个字符。使用否定的字符类时，当字符串包含有效的HTML代码时，根本不会发生回溯。回溯会减慢正则表达式引擎的速度。单次搜索时，差异不是很大，当循环中重复使用此类正则表达式时，将节省大量CPU。

当然，只有正则表达式导向的引擎会回溯，文本导向的引擎不会，因此不会受到速度损失。但是文本导向的引擎也不支持惰性量词。

