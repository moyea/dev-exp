# 微前端

## 从微服务(MicroServices)到微前端

> **微服务**（英语：Microservices）是一种[软件架构风格](https://zh.wikipedia.org/wiki/软件架构)，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic）的[API](https://zh.wikipedia.org/wiki/应用程序接口)集相互通信。  -- 摘自 维基百科

面向服务架构（SOA）的一种变体，把应用程序设计成一系列松耦合的细粒度服务，并通过轻量级的通信协议组织起来，具体地，将应用构建成一组小型服务。*这些服务都能够独立部署、独立扩展，每个服务都具有稳固的模块边界，甚至允许使用不同的编程语言来编写不同服务，也可以由不同的团队来管理*

而随着前端工程越来越重，为了解决单一项目的庞大难以扩展等问题，就有了将微服务思想应用到前端，于是有了微前端(MicroFrontend)的概念。具体来说，就是将前端应用分解为一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品.

## 微前端解决了什么问题?

首先来看前端的项目面临哪些问题:

1. 业务模块间耦合严重
2. 技术更新换代比较快，如何将新工具应用到老的环境中
3. 团队成员变更，导致新成员了解整个项目比较困难
4. 如何循序渐进的升级应用，而不是整体推翻重构

> 计算机科学领域的任何问题，都可以通过增加一层抽象去解决

同样，针对前端应用的这些问题，我们也可以增加一层抽象来解决。

通过微前端框架，建立应用间的主从关系（1个主应用+n个子应用），按业务功能将一整个前端应用分解成一系列更小，更内聚的微前端应用。同时通过明确的交互协议来管理这些应用间的依赖关系，实现不同业务模块的解耦。

这样，针对不同的模块，就可以将每个微前端应用交给独立的团队去开发部署，充分利用并行化。同时，在多技术栈并存的加持下，可以以更低的成本引入新的技术实践，也可以低风险的局部替换产品功能，这也就意味着依赖项升级，架构更新，UI改版等重大决策都能以循序渐进的方式平稳落地。

### 能否以组件化的方式去解决?

组件化也能实现拆分自治，比如React中可以通过 lazy+ Suspense 完成代码拆分，但是，这是建立在组件模型统一(或者说技术栈一致的前提下)，而微前端另一半的优势在于可以打破技术栈的限制（比如我一部分可以用React去实现，一部分可以用Vue去实现），这是组件化、模块化等方案所无法满足的。同样，git submodule，npm module等拆分方案也都无法直接提供多技术栈并存的能力。



微前端解决的主要问题，空间分离(团队规模变大)带来的协作问题以及时间延续(3、5年以上的项目)带来的升级维护问题，核心价值: **技术栈无关**。

「技术栈无关」是架构上的准绳，具体到实现时，对应的就是：**应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。**

比如我们不能要求子应用、主应用必须使用某一版本的技术栈实现。

比如在通信机制的设计与选择上，尽量基于浏览器原生的 CustomEvent api，而不是自己搞的 pub/sub。

比如子应用是否具备不依赖宿主环境独立运行的能力，衡量标准是是否能一行代码不改，或者只改很少的配置，就能达成这一目标。

所以我认为正确的微前端方案的目标应该是：方案上跟使用 iframe 做微前端一样简单，同时又解决了 iframe 带来的各种体验上的问题。

理想状态下，以此为目标的微前端应用，是自动具备流通能力的，且这个流通能力不会因为主应用的实现升级而丧失（也就是说在 19 年能接入主应用的微前端应用，到了 2025 年也应该能正常接入正常运行，并同样保有在不同主应用间流通的能力）。

**事实上如果所有的 web 技术栈能做到统一，所有 library 的升级都能做到向下兼容，我们确实就不需要微前端了。**



references:

- [微前端](http://www.ayqy.net/blog/micro-frontends/)

- [微前端在解决什么问题](https://juejin.cn/post/6844904023082926094)

- [为什么不是Iframe](https://www.yuque.com/kuitos/gky7yw/gesexv)

- [微前端的核心价值](https://www.yuque.com/kuitos/gky7yw/rhduwc)

